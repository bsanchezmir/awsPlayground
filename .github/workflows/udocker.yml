name: Check Dockerfile Base Image Updates and Validate with Image Digest

on:
  schedule:
    - cron: '0 0 * * *'  # Run daily
  workflow_dispatch:  # Allows manual triggering of the workflow

jobs:
  check-updates:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v1

    - name: Check for base image updates
      id: check
      run: |
        # Read the current base image from the Dockerfile, stopping at the first FROM instruction
        BASE_IMAGE=$(grep -oPm1 'FROM \K.*' Dockerfile | cut -d' ' -f1)
        echo "Base image from Dockerfile: $BASE_IMAGE"

        # Extract the image name and tag, ignoring any Dockerfile-specific annotations
        IMAGE_NAME=$(echo $BASE_IMAGE | cut -d':' -f1)
        echo "Image name extracted: $IMAGE_NAME"

        CURRENT_TAG=$(echo $BASE_IMAGE | cut -d':' -f2)
        echo "Current tag extracted: $CURRENT_TAG"

        # Use the Docker Hub API to get the latest tag, assuming the CURRENT_TAG follows semantic versioning
        LATEST_TAG=$(wget -qO- "https://hub.docker.com/v2/repositories/library/$IMAGE_NAME/tags/?page_size=100" | \
            jq -r "[.results[] | select(.name | startswith(\"$(echo $CURRENT_TAG | cut -d'-' -f1)\")) | .name] | max_by(split(\".\") | map(tonumber))")
        echo "Latest tag found: $LATEST_TAG"

        if [ "$CURRENT_TAG" != "$LATEST_TAG" ]; then
          echo "A newer base image tag is available: $LATEST_TAG"
          # Update Dockerfile with the new tag
          sed -i "s|$IMAGE_NAME:$CURRENT_TAG|$IMAGE_NAME:$LATEST_TAG|g" Dockerfile
          
          # Check the Dockerfile after sed operation
          echo "Dockerfile updated content:"
          cat Dockerfile
          
          # Use environment file to set the output
          echo "updated=true" >> $GITHUB_ENV
          echo "new_tag=$LATEST_TAG" >> $GITHUB_ENV
        else
          echo "No updates found. Current tag ($CURRENT_TAG) is up-to-date."
          echo "updated=false" >> $GITHUB_ENV
        fi

    - name: Build Docker Image and Get Digest
      if: env.updated == 'true'
      run: |
        docker build -t my-image:latest .
        DIGEST=$(docker images --digests my-image:latest | tail -n1 | awk '{print $3}')
        echo "Docker Image Digest: $DIGEST"
        echo "digest=$DIGEST" >> $GITHUB_ENV

    - name: Fetch Latest Image Digest from Docker Hub
      if: env.updated == 'true'
      run: |
        LATEST_DIGEST=$(wget -qO- "https://hub.docker.com/v2/namespaces/library/repositories/$IMAGE_NAME/tags/$LATEST_TAG" | jq -r '.images[] | select(.architecture=="amd64") | .digest')
        echo "Latest Image Digest: $LATEST_DIGEST"
        echo "latest_digest=$LATEST_DIGEST" >> $GITHUB_ENV

    - name: Compare Digests
      if: env.updated == 'true'
      run: |
        if [ "$digest" != "$latest_digest" ]; then
          echo "The local image digest does not match the latest image digest. An update is required."
          # Potentially trigger another job or step to handle the update
        else
          echo "The local image digest matches the latest image digest. No update is required."
          # Set an environment variable or output to indicate no further action is needed
          echo "digest_match=true" >> $GITHUB_ENV
        fi

    - name: Push changes and create a pull request
      if: env.updated == 'true' && env.digest_match != 'true'
      uses: peter-evans/create-pull-request@v6
      with:
        commit-message: Update Dockerfile to ${{ env.new_tag }} with digest ${{ env.digest }}
        title: Update base image to ${{ env.new_tag }} with digest ${{ env.digest }}
        body: |
          This is an automated PR to update the Dockerfile base image to ${{ env.new_tag }} with digest ${{ env.digest }}.
        branch: update-base-image-${{ env.new_tag }}-${{ env.digest }}
